## Item 26. 로 타입은 사용하지 말라

#### 용어

클래스와 인터페이스 선언에 타입 매개변수가 쓰이면 이를 **제네릭 클래스/제네릭 인터페이스** 라 한다.

둘을 통틀어 **제네릭 타입(generic type)** 이라 한다.

제네릭 타입은 **매개변수화 타입(parameterized type)** 을 정의한다. 예를 들어 List<String> 은 원소의 타입이 String 인 리스트를 뜻하는 매개변수화 타입이다. 

제네릭 타입을 하나 정의하면 그에 딸린 **로 타입(raw type)** 도 함께 정의된다. 로 타입이란 타입 매개변수를 사용하지 않았을 때를 말한다. List<E> 의 로 타입은 List 이다. 로 타입은 제네릭을 지원하기 전 코드와의 호환성을 위해 존재하는 타입이다.

<br>

**컬렉션의 로 타입** - 사용 금지

```java
// Stamp 인스턴스만 취급한다.
private final Collection stamp = ...;
stamp.add(new Coin(...)); // 다른 타입을 넣어도 빌드와 실행이 가능하다
// 하지만 사용을 위해서 stamp 에서 해당 값을 꺼내며 형변환시 예외가 발생하게 될 것이다
```

문제점

- 컴파일타임에 오류를 확인 할 수 없으며, 런타임 시 stamp 에서 Coin 을 꺼내 사용할때(런타임) 문제가 발생한다
  이렇게 되면 런타임에 문제를 겪는 코드와 원인을 제공한 코드가 괴리가 커 코드 전체를 봐야 할 수도 있다
- 첫라인의 주석은 컴파일러가 이해할 수 없어 별 도움이 되지 못한다

<br>

**매개변수화된 컬렉션 타입** - 타입 안정성이 확보된다

```java
private final Collection<Stamp> stamps = ...;
```

장점

- 컴파일타임에 오류를 확인 할 수 있다

<br>

로 타입 사용을 언어 차원에서 막아 놓지 않았지만 절대로 사용해서는 안된다. 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.

제네릭은 과거 코드와의 호환성만을 위해 남겨놓은 코드이다.

<br>

#### 비한정적 와일드카드 타입(unbounded wildcard type)

가장 범용적인 매개변수화 타입을 사용 할 수 있다.

```java
static int numElementsIncommon(Set<?> s1, Set<?> s2) {
  //...
}
```

비 한정적 와일드 카드 타입인 Set<?>와 로 타입인 Set 의 차이는 안정성이다. 와일드카드 타입은 안전하고, 로 타입은 안전하지 않다.

로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 **타입 불변식을 훼손하기 쉽다**. 반면 Collection<?>에는 (null 외에는) 어떤 원소도 넣을 수 없다.

다른 원소를 넣으려 하면 컴파일 시 오류 메시지를 보게 될 것이다.

컴파일러는 null 외의 어떤 원소도 Collection<?>에 넣지 못하게 하며, 컬렉션에서 꺼낼 수 있는 객체의 타입도 전혀 알 수 없게 했다.

이러한 제약을 받아들일 수 없다면 제네릭 메서드([아이템 30](Item30.md)) 나 한정적 와일드카드 타입([아이템 31](Item31.md)) 을 사용하면 된다.

<br>

#### 로 타입 사용 예외

1. class 리터럴에 로 타입 사용

   lass 리터럴에는 매개변수화 타입을 사용할 수 없다(배열과 기본 타입은 허용)

   List.class, String[].class, int.class 는 허용 / List<String>.class, List<?>.class 는 허용하지 않는다.

2. instanceof 연산자는 사용

   instanceof 연산자는 비한정적 와일드 카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.

   로 타입이든 비한정적 와일드카드 타입이든 instanceof 는 완전히 똑같이 동작한다. 따라서 비한정적 와일드카드 타입의 <> 와 ? 는 아무런 역할 없이 코드만 어지럽게 만드므로, 차라리 로 타입을 쓰는 편이 깔끔하다.

   ```java
   // 로 타입 사용의 올바른 예 - instanceof 연산자
   if (o instanceof Set) {   // 로 타입 (여기서는 굳이 <?>을 써줄 필요가 없다)
     Set<?> s = (Set<?>) o;  // 와일드카드 타입
     // ...
   }
   ```

<br>

<br>

***로 타입은 타입 안정성을 보장할 수 없으므로 사용해선 안된다.***

***로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.***